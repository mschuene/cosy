#+TITLE:Cognitive Systems model 
#+AUTHOR: Maik Sch√ºnemann
#+email: maikschuenemann@gmail.com
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  de
#+OPTIONS:   H:3 num:t toc:t :nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME:
#+TAGS:  BlowerDoor(b) Suub(s) Uni(u) Home(h) Task(t) Note(n) Info(i)
#+TAGS: Changed(c) Project(p) Reading(r) Hobby(f) OpenSource(o) Meta(m)
#+SEQ_TODO: TODO(t) STARTED(s) WAITING(w) APPT(a) | DONE(d) CANCELLED(c) DEFERRED(f) NEXT(n)
#+STARTUP:showall
#+LaTeX_CLASS: uni
-----

* Introduction
  this program evolved from a series of excercises from the course
  Cognitive Systems. It models how human perceive and group objects
  in a picture.

  It demonstrates the concepts only ... the tasks it has to solve are
  counting objects in a picture which match certain criteria in their
  shapes and color.
* Internal representations
** Picture
   A picture is stored as a 2-dimensional array of cells. Each cell is
   just a a map with the keys :color and :shape and the values are
   just keywords. A example picture can be represented like this:
   #+begin_src clojure :ns cosy.input :tangle src/cosy/input.clj
     (ns cosy.input
       (:require [clojure.core.matrix :as cm]
                 [cosy.memory :as mem]))

     (def example-array
       [[{} {} {} {} [:black :circle] {} {} {}]
        [{} {} {} {} {} {} [:blue :circle] {}]
        [[:yellow :square] [:blue :square] {} {} {} {} {} {}]
        [{} [:red :circle] [:blue :circle] {} {} {} {} {}]
        [{} [:black :circls] {} {} [:black :circle] {} {} [:blue :circle]]
        [[:blue :circle]{}{}[:red :triangle]{}{}[:red :circle][:blue :quare]]
        [{} {} [:blue :circle] {} [:yellow :square] {} {} {}]
        [[:red :circle] {} {} {} {} {} {} {}]])

     (swap! mem/memory assoc :stimulus example-array)

     (defn build-array [shape pos-2-val]
       (let [matrix (cm/compute-matrix :ndarray shape (fn [& args] []))]
         (doseq [[[x y] value] pos-2-val]
           (cm/mset! matrix x y value))
         (cm/coerce [] matrix)))




   #+end_src 

   #+RESULTS:
   : #'cosy.input/build-array

* Visualization
  Do demonstrate the behaviour of our cognitive architecture we want
  to visualize what the input arrays look like and what actions our 
  cognitive architecture is performing
  #+begin_src clojure :ns cosy.visualize :tangle src/cosy/visualize.clj
    (ns cosy.visualize
      (:require [quil.core :refer :all]
                [cosy.input :as in]
                [cosy.memory :as mem]))

    (defn setup []
      (smooth)                         
      (frame-rate 24)                  
      (background 200))

    (def cellwidth 30)
    (def cellheight 30)

    (def rgb-color {:red [255 0 0]
                    :grey [100 100 100]
                    :blue [0 0 255]
                    :green [0 255 0]
                    :yellow [255 255 0]
                    :black [0 0 0]})

    (defn get-rgb-color [cell]
      (get rgb-color (first cell) [255 255 255]))

    (def draw-funcs
      {:square #(rect (+ 2 %1) (+ 2 %2)
                      (- cellwidth 4)
                      (- cellheight 4))
       :circle #(ellipse (+ 15 %1) (+ 15 %2)
                         (- cellwidth 5)
                         (- cellheight 5))
       :triangle #(triangle (+ %1 15) %2
                            (+ %1 5) (+ %2 25)
                            (+ %1 25) (+ %2 25))
       :obscured #(do 
                      (triangle (+ %1 15) %2
                                   (+ %1 5) (+ %2 25)
                                   (+ %1 25) (+ %2 25))
                      (triangle (+ %1 15) (+ %2 30)
                                (+ %1 5) (+ %2 5)
                                (+ %1 25) (+ %2 5)))})

    (defn draw-shape [shape x y]
      ((get draw-funcs shape (constantly nil)) x y))

    (def visual-input (atom in/example-array))


    (defn visualize-rectangular-region [region]
      (begin-shape :lines)
      (let [[top-l top-r bottom-l bottom-r] region]
        ;;draw four lines
        (let [[x y] top-l]
          (vertex (* cellwidth x) (* cellheight y)))
        (let [[x y] top-r]
          (vertex (* cellwidth (inc x)) (* cellheight y)))
        (let [[x y] top-r]
          (vertex (* cellwidth (inc x)) (* cellheight y)))
        (let [[x y] bottom-r]
          (vertex (* cellwidth (inc x)) (* cellheight (inc y))))
        (let [[x y] bottom-r]
          (vertex (* cellwidth (inc x)) (* cellheight (inc y))))
        (let [[x y] bottom-l]
          (vertex (* cellwidth x) (* cellheight (inc y))))
        (let [[x y] bottom-l]
          (vertex (* cellwidth x) (* cellheight (inc y))))
        (let [[x y] top-l]
          (vertex (* cellwidth x) (* cellheight y))))
      (end-shape))

    (defn visualize-regions [regions]
      (doseq [[col colregions] regions
              region colregions]
       
       ; (fill (apply color (get-rgb-color [col])))
        (visualize-rectangular-region region)))

    (defn visualize-array []
      ;;each cell will be 25x25 pixel big
      (let [array (:stimulus @mem/memory)
            regions (:regions @mem/memory)]
        (fill 200)
        (rect 0 0 600 600)
        (doseq[[i y] (map-indexed
                      vector (range 0 (* cellwidth (count array))
                                    cellwidth))
               [j x] (map-indexed
                      vector (range 0 (* cellheight (count (first array)))
                                    cellheight))]
          (fill (apply color (get-rgb-color (get-in array [i j]))))
          (draw-shape (second (get-in array [i j])) x y))
        (visualize-regions regions)))

    (defn boundaries-of-region [region])

    (defsketch example                 
      :title "Clojure is back!" 
      :setup setup                     
      :draw visualize-array
      :size [600 600])           

    #_(let [gen (first (cosy.gen/generate-next-array))]
                       (swap! mem/memory assoc 
                              :stimulus gen
                              :color-regions 
                              (color-regions gen [:red])))

    (def example (:stimulus @mem/memory))
  #+end_src 

  #+RESULTS:
  : #'cosy.visualize/example

* Generation of Visual Inputs
  We want to test our cognitive systems as much as possible and it is
  therefore important to generate example arrays quickly.
  Generative testing is the trick here with clojure's test.check
  library it is not hard to generate example arrays.
  #+begin_src clojure :ns cosy.gen :tangle src/cosy/gen.clj
    (ns cosy.gen
      (:require [clojure.test.check :as tc]
                [clojure.test.check.generators :as gen]
                [clojure.test.check.properties :as prop]
                [cosy.input :as in]))


    (defn gen-array []
      (let [x (gen/choose 18 20)
            y (gen/choose 18 20)
            s (gen/frequency [[15 (gen/elements
                                  [:circle :square
                                   :triangle])]
                              [1 (gen/return :obscured)]])
            c (gen/elements [:black :blue :red :yellow :green])
            elemc (gen/choose 15 200)]
        (as-> (gen/tuple elemc x y) gen
              (gen/bind gen (fn [[ec x y]]
                              (gen/tuple
                               (gen/vector
                                (gen/tuple (gen/choose 0 (dec x))
                                           (gen/choose 0 (dec y))
                                                      s c) ec)
                               (gen/return x) (gen/return y))))
              (gen/fmap (fn [[v x y]]
                          (->> (for [[x y s c] v]
                                 [[x y] [(if (= :obscured s) :grey c) s]])
                               (into {})
                               (in/build-array [x y]))) gen))))

    (defn generate-next-array []
      (gen/sample (gen-array) 1))

    ;;todo work more closely together with memory
    ;;goodby pureness hello human mind
  #+end_src 

  #+RESULTS:
  : #'cosy.gen/generate-next-array

* Components
   The system needs the following components to model the human behaviour
   - perception - from a picture to informations contained in it
   - Memory - The human equivalent of storage/cache
   - Processing unit - the human cpu

** Memory
   #+begin_src clojure :ns cosy.memory :tangle src/cosy/memory.clj
     (ns cosy.memory)

     (def memory
       ;;my memory is as big as an
       (atom {}))
   #+end_src 

   #+RESULTS:
   : #'cosy.memory/memory

** Perception
   The perception is the most important cognitive component when the
   goal is to model the human behaviour.
   Scanning the shown picture top to botton left to right is trivial
   to implement and efficient for a computer, but a human does not
   perceive the world in this way.
   A Human automatically filters much information that is not needed
   for the task at hand and therefore does *not* look at each cell in
   order to count objects.

*** How does a Human perceive and process a visual input to count objects in it
    Take this picture for example:
    [[file:cosy.png][A sample visual stimuli]]
    When looking at the picture we instantly see where the colors are,
    so when the task is to count the red circles we are not even
    concerned about the top right area of the picture. Shapes are a
    little harder to recognize.
    How do we do this? 
    - We cannot focus on the whole picture all at once but only see
      sharply at the center of our viewpoint. In the rest of our
      view we can't see details but we can recognize where what colors
      are on the picture.
    - afterwards, we know where to focus and then move our eyes so
      that we can recognize the details in the areas.
    - Even the focus-view does not look sequentially at each cell of
      the picture but can scan a whole (presumably circle but
      simplified to a rectangular area for this project) area at once
    - We perform thus the minimal eye movement in order to focus at
      each interesting area one time and are so filtering a large part
      of the picture
    
*** Implementation
**** Simplifications/Assumptions
     We are going to assume that our system only has to process images
     that aren't too big so that the whole picture fits in the
     peripheral view field and we can quickly perceive where certain
     colors are.
     With focus view, we are able to process a small square area of
     the image at once (say 4x4 cells)
**** Peripheral view - recognize boundaries for regions of color
     our first attempt at peripheral view will be to narrow down the
     picture to the ranges of cells where the color is that we are
     searching for
     #+begin_src clojure :ns cosy.peripheral :tangle src/cosy/peripheral.clj
        (ns cosy.peripheral
          (:require [cosy.input :as in]
                    [cosy.memory :as mem])
            (:use [cosy.utils]))

       (defn obscured? [cell]
         (= :obscured (second cell)))

       (defn coordinates [stimuli pred?]
         (for [[i row] (map-indexed (fn [& v] v) stimuli)
               [j cell] (map-indexed (fn [& v] v) row)
               :when (or (pred? cell) (obscured? cell))]
           [i j]))

       (defn obscured-only? [rectangle]
         (and (apply = rectangle)
              (let [[x y] (first rectangle)]
                (= :obscured (second
                              (get-in (:stimulus @mem/memory)
                                             [y x]))))))

       (defn regions [type stimuli to-look-for]
         ;; first find all coordinates of objects with the intersting-color
         (->>
          (for [feature to-look-for]
            [feature
             (->> (coordinates stimuli #(= feature ((if (= type :color)
                                                      first second) %))) 
                  (map vector)        ;initial regions
                  merge-regions       ;;merge them
                  (map to-rectangle)  ;; only rectangles can be recognized
                                      ;; by peripheral view
                  (remove obscured-only?))]) ;;remove regions containing only
                                            ;;one obscured object
            (into {})))                   
         
       (defn peripheral-view
         "type can be :color or :shape"
         [type for-what]
         (let [stimulus (:stimulus @mem/memory)]
           (swap! mem/memory
                  update-in [:regions]
                  (fn [regs]
                    (merge regs (regions type stimulus for-what))))))
     #+end_src 

     #+RESULTS:
     : #'cosy.peripheral/coordinates

**** Focus view-apply visual routines and count the objects of interest
     #+begin_src clojure :ns cosy.focus :tangle src/cosy/focus.clj
       (ns cosy.focus
         (:require [cosy.input :as in]
                   [cosy.memory :as mem]
                   [clojure.set :as set]
                   [clojure.core.matrix :as cm]))

       (def focus-diam 2)

       (def example-region
         [[[:gray :obscured] [:red :circle] [:red :circle] [] [:red :circle]]
          [[:red :circle] [:red :circle] [:red :circle] [] [:red :circle]]
          [[:red :circle] [:red :circle] [:red :circle] [] [:red :circle]]])

       ;;isnt this merge regions with separation distance 1?
       ;;time for util namespace

       (defn obscured? [cell]
         (= :obscured (second cell)))

       (defn check-constraints [position colors shapes]
         (let [[colc shapec] (get (:obscured @mem/memory) position)]
           (if (and colc shapec)
             (do (prn "colc shapec " colc shapec)
                 (and (some colc colors) (some shapec shapes)))
             true)))

       ;;color-pred and shape-pred have to be sets
       (defn matches? [region position color-pred? shape-pred?]
         (let [[color shape] (get-in region position)]
           (or (and color (color-pred? color) (shape-pred? shape))
               (and (obscured? [color shape])
                    (check-constraints position color-pred? shape-pred?)))))

       (defn adjacent-cells [region color-pred? shape-pred? [x y]]
         (let [directions (for [dx [-1 0 1] dy [-1 0 1]] [dx dy])]
           (->> directions
                (#(do (prn %) %))
                (map (fn [[dx dy]]
                          (if (and (> (count region) (+ x dx) -1)
                                   (> (count (first region)) (+ y dy) -1))
                            [(get-in region [(+ x dx) (+ y dy)])
                             [(+ x dx) (+ y dy)]]
                            [[] []])))
                (#(do (prn %) %))
                (filter (comp #(matches? % color-pred? shape-pred?) first))
                ;;TODO change call to matches on top
                (map second)
                (into #{}))))

       (defn get-cluster [region color-pred? shape-pred? position]
         (loop [adj #{position}]
           (let [nadj (apply set/union
                             (map #(adjacent-cells
                                    region
                                    color-pred?
                                    shape-pred?
                                    %) adj))]
             (if (= (count adj) (count nadj))
               adj
               (recur  nadj)))))



       (defn %-obscured [region cluster]
         (/ (count (filter #(obscured? (get-in region %)) cluster))
            (count cluster)))

       (defn recognize-square [region color-pred? shape-pred? [i j]]
         (let [current-cell (get-in region [i j])]
           ;;assume it is the top left cell of a square - sound.
           (loop [size 2
                  matching-cluster nil]
             (let [cluster (for [i (range i (+ i size))
                                j (range j (+ j size))]
                             [i j])]
               (if (and
                    (every?
                     #(matches? region % color-pred? shape-pred?)
                     cluster)
                    (<= (%-obscured region cluster) 0.5))
                 (recur (inc size) cluster)
                 (if-not (= size 2) ;;no square found
                   [matching-cluster {:tpye :square
                                 :size (dec size)
                                 :cluster matching-cluster}]
                   )
                 )))))

       (defn recognize-cross [region color-pred? shape-pred? [i j]]
         (let [cluster
               #{[i j] [(inc i) (dec j)] [(inc i) j]
                 [(inc i) (inc j)][(+ i 2) (inc j)]}]
           (when (and
                  (every? #(matches? region %
                                     color-pred?
                                     shape-pred?)
                          cluster)
                  (<= (%-obscured region cluster) 0.5))
             [cluster {:type :cross}])))

       (defn recognize-line [region color-pred? shape-pred? [i j]]
         (let [horizontal
               (loop [j j cluster #{[i j]}]
                 (if (matches? region [i j]
                               color-pred?
                               shape-pred?)
                   (recur (inc j) (conj cluster [i j]))
                   cluster))
               vertical
               (loop [i i cluster #{[i j]}]
                 (if (matches? region [i j]
                               color-pred?
                               shape-pred?)
                   (recur (inc i) (conj cluster [i j]))
                   cluster))
               recognized (if (and (>= (count horizontal) (count vertical))
                                   (<= (%-obscured region horizontal) 0.5))
                            horizontal
                            (when (<= (%-obscured region vertical) 0.5)
                              vertical))]
           (when (>= (count recognized) 2)
             [recognized {:type :line
                          :length (count recognized)
                          :cluster recognized}])))

       (defn recognize-point [region color-pred? shape-pred? position]
         (when-not (obscured? (get-in region position))
           [#{position} {:type :point
                         :cluster #{position}}]))

       ;;return recognized objects or nil
       (def visual-routines
         [recognize-square
          recognize-cross
          recognize-line
          recognize-point
          ])

       (defn apply-visual-routines [region color-pred? shape-pred? position]
         (some #(% region color-pred? shape-pred? position)
               visual-routines))
       ;;ok next approach - don't return whole cluster but for each position
       ;;try in the visual routines if there is a object

       (defn next-location [region current-location looked-at]
         (let [rowc (count region)
               colc (count (first region))
               _ (prn "region " region)
               [r c] current-location
               nl (cond
                   (> colc (inc c)) [r (inc c)]
                   (> rowc (inc r)) [(inc r) 0]
                   :else nil)]
           (if ((set looked-at) nl)
             (recur region nl looked-at)
             nl)))

       (defn add-message [message]
         (swap! mem/memory update-in [:messages]
                #(concat % [message])))
       ;;make sure to harden constraints if ther are already constraints
       ;;it is valid to assume that the constraints don't contradict each
       ;;other see check-constraints in matches?

       (defn harden-constraints [[colorcn shapecn]
                                 [colorco shapeco]]
         (if (and colorco shapeco)
           [(set/intersection colorcn colorco)
            (set/intersection shapecn shapeco)]
           [colorcn shapecn]))

       (defn add-obscured-constraints [region cluster color-pred? shape-pred?]
         (if-let [obscured-cells (seq (filter #(obscured? (get-in region %))
                                              cluster))]
           (do (prn "obscurec-cells" obscured-cells)
            (swap! mem/memory
                   update-in [:obscured]
                   #(apply assoc %
                           (mapcat (fn [obsc]
                                     [(mapv + obsc (:offset @mem/memory))
                                      (harden-constraints
                                       [color-pred? shape-pred?]
                                       (get (:obscured @mem/memory) obsc))])
                                   obscured-cells)))))

         (defn add-recognized-object [recognized]
           (swap! mem/memory update-in [:recognized]
                  (fnil #(conj % recognized) [])))

         (defn scan-region [region color-pred? shape-pred?]
           (loop [position [0 0] looked-at #{} recognized-objects []]
             ;;search for matching-cell
             (add-message (str "looking at " position))
             (prn "current-position " position
                  "looked at " looked-at
                  "recognized-objects " recognized-objects)
             (cond
              (nil? position) (do (add-message "scanned whole region")
                                  recognized-objects)
              (matches? region position color-pred? shape-pred?)
              (let [_ (prn "found something -look for visual-routines")
                    [visited recognized]
                    (apply-visual-routines
                     region color-pred? shape-pred? position)]
                (if recognized
                  (let [_ (add-message (str "found " (pr-str recognized)
                                            "on the cells" (pr-str visited)))
                        looked-at (set/union looked-at visited)
                        _ (add-obscured-constraints region visited
                                                    color-pred? shape-pred?)
                        _ (add-recognized-object recognized)]
                    (recur (next-location region position looked-at)
                           looked-at
                           (conj recognized-objects recognized)))
                  (recur (next-location region position looked-at)
                         looked-at recognized-objects)))
              :else (recur (next-location region position looked-at)
                           looked-at recognized-objects)))))
                                                   
          

       (defn get-contents [color-region visual-stimulus]
         (prn "color-region" color-region)
         (let [[topl _ _ bottomr] color-region]
           (cm/coerce
            [] (cm/select visual-stimulus
                          (range (second topl) (inc (second bottomr)))
                          (range (first topl) (inc (first bottomr)))))))

       (defmulti elemcount :type)

       (defmethod elemcount :point [_] 1)
       (defmethod elemcount :cross [_] 5)
       (defmethod elemcount :square [sq]
         (* (:size sq) (:size sq)))
       (defmethod elemcount :line [l]
         (:length l))

       (defn sum-elements-in-region [scanned-region]
         (reduce #(+ %1 (elemcount %2)) 0 scanned-region))

       (defn count-region [stimulus color-region color-pred? shape-pred?]
         (-> color-region
             (#(do (prn "cr " %) %))
             (get-contents stimulus)
             (#(do (prn "regs " %) %))
             (scan-region color-pred? shape-pred?)
             (#(do (prn "scanned " %) %))
             sum-elements-in-region))

       (defn focus-view [colors shapes]
         ;;look through the regions for colors recognized by peripheral view
         (let [regions (:regions @mem/memory)]
           (doseq [color colors
                   reg (get regions color)]
             (let [offset [(second (first reg)) (ffirst reg)]
                   _ (swap! mem/memory assoc :offset offset)
                   region (get-contents reg
                                        (:stimulus @mem/memory))]
               (scan-region region #{color} (into #{} shapes))))))

       ;;todo translate between coordinates on the local region to
       ;;coordinates on the whole picture
     #+end_src 

     #+RESULTS:
     : #'cosy.focus/count-region

* Utilities
  #+begin_src clojure :ns cosy.utils :tangle src/cosy/utils.clj
    (ns cosy.utils)


    (defn to-rectangle [region]
      (let [is (map first region)
            js (map second region)]
        [[(apply min js) (apply min is) ]
         [(apply max js) (apply min is)]
         [(apply min js) (apply max is)]
         [(apply max js) (apply max is)]]))

    (defn distance
      "distance between two cells given by their coordinates in the array"
      [[x1 y1] [x2 y2]]
      (+ (Math/abs (- x1 x2)) (Math/abs (- y1 y2))))

    #_(defn close-enough [region1 region2 separating-distance]
      (let [rectangles (for [rect1 region1 rect2 region2] [rect1 rect2])]
        (and (some (fn [[l r]]
                     (<= (distance l r) separating-distance)) rectangles)
             region1)))

    (defn close-enough [region1 region2 separating-distance]
      (let [[[tlj1 tli1] _ _ [brj1 bri1]] (to-rectangle region1)
            [[tlj2 tli2] _ _ [brj2 bri2]] (to-rectangle region2)
            rect-region1 (for [i (range tli1 (inc bri1))
                               j (range tlj1 (inc brj1))] [i j])
            rect-region2 (for [i (range tli2 (inc bri2))
                               j (range tlj2 (inc brj2))] [i j])
            rectangles (for [rect1 rect-region1
                             rect2 rect-region2] [rect1 rect2])]
        (and (some (fn [[l r]]
                     (<= (distance l r) separating-distance)) rectangles)
             region1)))

    (defn merge-regions
      ([regions] (merge-regions regions 2))
      ([regions distance]
         ;;merge regions that are close enough
         ;;merge until there is nothing to merge anymore
         (loop [regions regions]
           (let [rc (count regions)
                 merged
                 (reduce
                  (fn [regions region]
                    ;;if some region is close enough
                    (if-let [reg
                             (some #(close-enough %1 region distance)
                                   regions)]
                      (replace {reg (concat reg region)} regions)
                      (concat regions [region])))
                  [] regions)]
             (prn "merged " merged)
             (if (= (count merged) rc)
               merged
               (recur merged))))))

    (defn to-rectangle [region]
      (let [is (map first region)
            js (map second region)]
        [[(apply min js) (apply min is) ]
         [(apply max js) (apply min is)]
         [(apply min js) (apply max is)]
         [(apply max js) (apply max is)]]))
  #+end_src 

  #+RESULTS:
  : #'cosy.utils/to-rectangle

* Main 
  #+begin_src clojure :ns cosy.main :tangle src/cosy/main.clj
    (ns cosy.main
      (:require [cosy.input :as in]
                [cosy.memory :as mem]
                [cosy.gen]
                [cosy.peripheral :as peri]
                [cosy.focus :as focus]))

    (defmulti elemcount :type)
    (defmethod elemcount :point [_] 1)
    (defmethod elemcount :cross [_] 5)
    (defmethod elemcount :square [sq]
      (* (:size sq) (:size sq)))
    (defmethod elemcount :line [l]
      (:length l))

    (defn sum-elements [scanned-region]
      (reduce #(+ %1 (elemcount %2)) 0 scanned-region))

    (defn new-stimulus []
      (swap! mem/memory dissoc :recognized :obscured :messages :regions)
      (let [gen (first (cosy.gen/generate-next-array))]
        (swap! mem/memory assoc 
               :stimulus gen)))

    (defn count-objects [colors shapes]
      (peri/peripheral-view :color colors)
      (focus/focus-view colors shapes)
      (sum-elements (:recognized @mem/memory)))
  #+end_src 
